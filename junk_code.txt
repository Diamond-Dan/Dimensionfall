


# Function to get slope vertices facing east
func get_slope_vertices_east1(half_block: float, slopeposition: Vector3) -> PackedVector3Array:
	return PackedVector3Array([
		Vector3(half_block, half_block, -half_block) + slopeposition,
		Vector3(half_block, half_block, half_block) + slopeposition,
		Vector3(-half_block, -half_block, half_block) + slopeposition,
		Vector3(-half_block, -half_block, -half_block) + slopeposition
	])
	
	
	
# Function to get slope vertices facing west
func get_slope_vertices_west1(half_block: float, slopeposition: Vector3) -> PackedVector3Array:
	return PackedVector3Array([
		Vector3(-half_block, half_block, half_block) + slopeposition,
		Vector3(-half_block, half_block, -half_block) + slopeposition,
		Vector3(half_block, -half_block, -half_block) + slopeposition,
		Vector3(half_block, -half_block, half_block) + slopeposition
	])
	
	
	
# Function to get slope vertices facing south
func get_slope_vertices_south1(half_block: float, slopeposition: Vector3) -> PackedVector3Array:
	return PackedVector3Array([
		Vector3(half_block, half_block, half_block) + slopeposition,
		Vector3(-half_block, half_block, half_block) + slopeposition,
		Vector3(-half_block, -half_block, -half_block) + slopeposition,
		Vector3(half_block, -half_block, -half_block) + slopeposition
	])





# Function to get slope vertices facing north
func get_slope_vertices_north(half_block: float, slopeposition: Vector3) -> PackedVector3Array:
	return PackedVector3Array([
		Vector3(-half_block, half_block, -half_block) + slopeposition,
		Vector3(half_block, half_block, -half_block) + slopeposition,
		Vector3(half_block, -half_block, half_block) + slopeposition,
		Vector3(-half_block, -half_block, half_block) + slopeposition
	])


func setup_slope1(pos: Vector3, block_data: Dictionary, verts: PackedVector3Array, uvs: PackedVector2Array, normals: PackedVector3Array, indices: PackedInt32Array, top_face_uv: PackedVector2Array):
	var block_rotation = block_data.get("rotation", 0)
	var slope_vertices = calculate_slope_vertices(block_rotation, pos)
	
	# Add the vertices for the slope
	verts.append_array(slope_vertices)
	
	# Add UV coordinates for each vertex
	var uv_count = slope_vertices.size()
	for _i in range(uv_count):
		uvs.append_array(top_face_uv)
	
	# Add normals for each vertex
	var normal = Vector3(0, 1, 0)  # Assuming a simple upward normal; adjust as needed
	for _i in range(uv_count):
		normals.append(normal)
	
	# Add indices for the top face and side faces
	var base_index = verts.size() - uv_count
	for i in range(0, uv_count, 3):
		indices.append(base_index + i)
		indices.append(base_index + i + 1)
		indices.append(base_index + i + 2)





# Function to add normals and indices for slopes
func add_slope_normals_and_indices(verts, normals, indices):
	var normal = Vector3(0, 1, 0)
	for _i in range(4):
		normals.append(normal)
	var base_index = verts.size() - 4
	indices.append_array([
		base_index, base_index + 1, base_index + 2,
		base_index, base_index + 2, base_index + 3
	])



func switch_level1(level_name: String, global_pos: Vector2) -> void:
	ready_to_switch_level.save_ready = false
	ready_to_switch_level.chunks_unloaded = false
	current_level_name = level_name
	# This is only true if the game has just initialized
	# In that case no level has once been loaded so there is no game to save
	if current_level_pos != Vector2(0.1,0.1):
		save_helper.save_current_level(current_level_pos)
		save_helper.save_overmap_state()
		save_helper.save_player_inventory()
		save_helper.save_player_equipment()
		save_helper.save_player_state(get_tree().get_first_node_in_group("Players"))
		chunk_navigation_maps.clear()
	else:
		ready_to_switch_level.chunks_unloaded = true
	current_level_pos = global_pos
	ready_to_switch_level.save_ready = true
	start_timer()




func _physics_process1(delta):
	time_since_ready += delta
	if time_since_ready < delay_before_movement:
		# Skip movement updates during the delay period. Otherwise the player 
		# will fall into the ground because the ground is still being spawned.
		return

	# Added an arbitrary multiplier because without it, the player will fall slowly
	var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")
	velocity.y -= gravity * 12 * delta
	move_and_slide()
	
		
	if is_alive:
		var input_dir = Input.get_vector("left", "right", "up", "down")
		var direction = (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
		
		# Check if the player is pushing furniture
		if pushing_furniture and furniture_body:
			# Get the mass of the RigidBody3D
			var mass = furniture_body.mass
			# Calculate resistance based on the mass
			var resistance = 1.0 / mass
			# Apply resistance to the player's movement
			velocity = direction * speed * resistance
		else:
			if !is_running || current_stamina <= 0:
				velocity = direction * speed
			elif is_running and current_stamina > 0:
				velocity = direction * speed * run_multiplier
				
				if velocity.length() > 0:
					current_stamina -= delta * stamina_lost_while_running_persec
				
		if velocity.length() < 0.1:
			current_stamina += delta * stamina_regen_while_standing_still
			if current_stamina > stamina:
				current_stamina = stamina

		update_stamina_HUD.emit(current_stamina)
		
		move_and_slide()
